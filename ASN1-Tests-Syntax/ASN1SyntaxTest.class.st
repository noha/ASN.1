Class {
	#name : #ASN1SyntaxTest,
	#superclass : #PPCompositeParserTest,
	#category : 'ASN1-Tests-Syntax'
}

{ #category : #accessing }
ASN1SyntaxTest class >> moduleDefinition [
	^ '-- Generated by Asnp, the pretty-printer of France Telecom R&D (http://asn1.elibel.tm.fr/asnp/)
-- Module TCAPMessages (Q.773:06/1997)
-- asn1ct:compile("TCAPMessages",[ber_bin]).
TCAPMessages {itu-t recommendation q 773 modules(2) messages(1) version3(3)}

DEFINITIONS IMPLICIT TAGS

::=

BEGIN

-- EXPORTS everything
-- Transaction Portion fields.
IMPORTS
  ROS{}, InvokeId
    FROM Remote-Operations-Generic-ROS-PDUs {joint-iso-itu-t
      remote-operations(4) generic-ROS-PDUs(6) version1(0)}
  OPERATION
    FROM Remote-Operations-Information-Objects {joint-iso-itu-t
      remote-operations(4) informationObjects(5) version1(0)}
  Supported-MAP-Operations
    FROM MAP-Protocol {itu-t identified-organization (4) etsi (0) mobileDomain (0)
   	 gsm-Network (1) modules (3) map-Protocol (4) version12 (12)}
-- Start - Added by Eranga
  dialogue-as-id
    FROM DialoguePDUs {itu-t recommendation q 773 modules(2) dialoguePDUs(2)
      version1(1)}
  sendRoutingInfoForSM,
  mo-ForwardSM,
  mt-ForwardSM,
  reportSM-DeliveryStatus,
  alertServiceCentre,
  informServiceCentre,
  readyForSM
	FROM MAP-ShortMessageServiceOperations {
	   itu-t identified-organization (4) etsi (0) mobileDomain (0)
	   gsm-Network (1) modules (3) map-ShortMessageServiceOperations (9)
	   version12 (12)}
  gsm-MessagingId
  	FROM MobileDomainDefinitions {
	   itu-t identified-organization (4) etsi (0) mobileDomain (0)
	   mobileDomainDefinitions (0) version1 (1)}
  Supported-MAP-Operations
  	FROM MAP-Protocol {
	   itu-t identified-organization (4) etsi (0) mobileDomain (0)
	   gsm-Network (1) modules (3) map-Protocol (4) version12 (12)}
-- End - Added by Eranga
;

-- Start - Added by Eranga

mapSpecificAS ABSTRACT-SYNTAX ::= {
  MapSpecificPDUs
  IDENTIFIED BY  gsm-MessagingId
}

MapSpecificPDUs ::=
  TCMessage{{Supported-MAP-Operations}, {Supported-MAP-Operations}}


MAPOperations-Invokable OPERATION ::= 
	{sendRoutingInfoForSM | mo-ForwardSM | mt-ForwardSM} 
MAPOperations-Returnable OPERATION ::= 
	{reportSM-DeliveryStatus | alertServiceCentre | informServiceCentre | readyForSM} 

-- End - Added by Eranga


TCMessage{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  unidirectional  [APPLICATION 1]  Unidirectional{{Invokable}, {Returnable}},
  begin           [APPLICATION 2]  Begin{{Invokable}, {Returnable}},
  end             [APPLICATION 4]  End{{Invokable}, {Returnable}},
  continue        [APPLICATION 5]  Continue{{Invokable}, {Returnable}},
  abort           [APPLICATION 7]  Abort
}

Unidirectional{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}}
}

Begin{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  otid             OrigTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}

End{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  dtid             DestTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}

Continue{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  otid             OrigTransactionID,
  dtid             DestTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}

Abort ::= SEQUENCE {
  dtid    DestTransactionID,
  reason  CHOICE {p-abortCause  P-AbortCause,
                  u-abortCause  DialoguePortion} OPTIONAL
}

-- NOTE - When the Abort Message is generated by the Transaction sublayer, a p-Abort Cause may be 
-- present. The u-abortCause may be generated by the component sublayer in which case it is an ABRT 
-- APDU, or by the TC-User in which case it could be either an ABRT APDU or data in some user-defined
-- abstract syntax.
DialoguePortion ::= [APPLICATION 11] EXPLICIT EXTERNAL

-- The dialogue portion carries the dialogue control PDUs as value of the external data type. The direct 
-- reference should be set to {itu-t recommendation q 773 as(1) dialogue-as(1) version1(1)} if structured 
-- dialogue is used and to {itu-t recommendation q 773 as(1) unidialogue-as(2) version1(1)} if unstructured 
-- dialogue is used.
OrigTransactionID ::= [APPLICATION 8]  OCTET STRING(SIZE (1..4))

DestTransactionID ::= [APPLICATION 9]  OCTET STRING(SIZE (1..4))

P-AbortCause ::= [APPLICATION 10]  INTEGER {
  unrecognizedMessageType(0), unrecognizedTransactionID(1),
  badlyFormattedTransactionPortion(2), incorrectTransactionPortion(3),
  resourceLimitation(4)}(0..127)

-- COMPONENT PORTION. The last field in the transaction portion of the TCAP message is the 
-- component portion. The component portion may be absent.
ComponentPortion{OPERATION:Invokable, OPERATION:Returnable} ::=
  [APPLICATION 12] 
    SEQUENCE SIZE (1..MAX) OF Component{{Invokable}, {Returnable}}

-- Component Portion fields
-- Recommendation X.880 defines four Application Protocol Data Units (APDUs) for invoking
-- operations, returning results or error, and for the rejection of invalid PDUs.
-- TCAP adds returnResultNotLast to allow for the segmentation of a result.
Component{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  basicROS             ROS{{TCInvokeIdSet}, {Invokable}, {Returnable}},
  returnResultNotLast
    [7]  returnResult < ROS{{TCInvokeIdSet}, {Invokable}, {Returnable}}
}

TCInvokeIdSet ::= InvokeId(WITH COMPONENTS {
                             present  (-128..127)
                           })

END' 
]

{ #category : #accessing }
ASN1SyntaxTest class >> packageNamesUnderTest [
	^ #('ASN1')
]

{ #category : #accessing }
ASN1SyntaxTest >> parserClass [
	^ ASN1Syntax 
]

{ #category : #tests }
ASN1SyntaxTest >> testActualParameterList [
	self parse: '{ {Supported-MAP-Operations}, {Supported-MAP-Operations}}' rule: #actualParameterList.

]

{ #category : #tests }
ASN1SyntaxTest >> testAlternativeTypeList [
	self parse: 'unidirectional  [APPLICATION 1]  Unidirectional{{Invokable}, {Returnable}},
  begin           [APPLICATION 2]  Begin{{Invokable}, {Returnable}},
  end             [APPLICATION 4]  End{{Invokable}, {Returnable}},
  continue        [APPLICATION 5]  Continue{{Invokable}, {Returnable}},
  abort           [APPLICATION 7]  Abort' rule: #alternativeTypeList.

]

{ #category : #tests }
ASN1SyntaxTest >> testAssignedIdentifier [
	self parse: '' rule: #assignedIdentifier.
	self parse: 'foobar' rule: #assignedIdentifier.
	self parse: 'foobar{Foo}' rule: #assignedIdentifier.
	self parse: '{ one two(2) three }' rule: #assignedIdentifier.

]

{ #category : #tests }
ASN1SyntaxTest >> testAssignmentList [
	self parse: 'TCMessage{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  unidirectional  [APPLICATION 1]  Unidirectional{{Invokable}, {Returnable}},
  begin           [APPLICATION 2]  Begin{{Invokable}, {Returnable}},
  end             [APPLICATION 4]  End{{Invokable}, {Returnable}},
  continue        [APPLICATION 5]  Continue{{Invokable}, {Returnable}},
  abort           [APPLICATION 7]  Abort
}

Unidirectional{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}}
}

Begin{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  otid             OrigTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}
' rule: #assignmentList.

]

{ #category : #tests }
ASN1SyntaxTest >> testAtNotation [
	self parse: '@identifier' rule: #atNotation.
	self parse: '@.identifier' rule: #atNotation.
	self parse: '@...identifier.bla' rule: #atNotation.

]

{ #category : #tests }
ASN1SyntaxTest >> testBString [
	self parse: '''0010011''B' rule: #bString.
	self parse: '''001 0011''B' rule: #bString.
	self parse: '''001 00
	11''B' rule: #bString.
	self fail: '''001 0011''' rule: #bString.
	self fail: '''001 0011B' rule: #bString.
	self fail: '001 0011''B' rule: #bString.
	self fail: '''0012011''B' rule: #bString.
	self assert: (self parse: '''0010011''B' rule: #bString) size = 7
]

{ #category : #tests }
ASN1SyntaxTest >> testBitStringType [
	self parse: 'BIT STRING {
        msc-s (0),
        mgw (1),
        sgsn (2),
        ggsn (3),
        rnc (4),
        bm-sc (5) ,
        mme (6),
        sgw (7),
        pgw (8),
        eNB (9)}' rule: #bitStringType.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testBitStringValue [
	self parse: '''010101''B' rule: #bitStringValue.
	self parse: '''DEADBEEF''H' rule: #bitStringValue.
	self parse: '{ foo }' rule: #bitStringValue.
	self parse: '{ foo , bar }' rule: #bitStringValue.
	self parse: 'CONTAINING foo' rule: #bitStringValue.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testBooleanValue [
	self parse: 'TRUE' ruleSelector: #booleanValue.
	self parse: 'FALSE' ruleSelector: #booleanValue.
	self parse: ' TRUE' ruleSelector: #booleanValue.
	self parse: 'FALSE ' ruleSelector: #booleanValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testCString [
	self parse: '"hello world"' rule: #cString.
	self parse: '"hello""world"' rule: #cString.
	self parse: '"hello""world""world"' rule: #cString.
	self parse: '"hello""""world"' rule: #cString.
	self parse: '""""' rule: #cString.

]

{ #category : #tests }
ASN1SyntaxTest >> testCharSyms [
	self parse: '"hello world",{8,9}, abc, Foo.abc' rule: #charSyms.

]

{ #category : #tests }
ASN1SyntaxTest >> testCharacterStringList [
	self parse: '{ "hello world",{8,9}, abc, Foo.abc }' rule: #characterStringList.

]

{ #category : #tests }
ASN1SyntaxTest >> testCharacterStringType [
	self parse: 'CHARACTER STRING' rule: #characterStringType

]

{ #category : #tests }
ASN1SyntaxTest >> testCharsDefn [
	self parse: '"hello world"' rule: #charsDefn.
	self parse: '"hello""world"' rule: #charsDefn.
	self parse: '"hello""world""world"' rule: #charsDefn.
	self parse: '{8,9}' rule: #charsDefn.
	self parse: '{1,2,3,4}' rule: #charsDefn.
	self parse: 'abc' rule: #charsDefn.
	self parse: 'Foo.abc' rule: #charsDefn.

]

{ #category : #tests }
ASN1SyntaxTest >> testChoiceType [
	| alternativeTypeList |
	self parse: 'CHOICE {
  reroutingNumber    [0] IMPLICIT IsdnNumber,
  forwardedToNumber  [1] IMPLICIT IsdnNumber
}' rule: #choiceType.
	alternativeTypeList := 'foo Bar, name Type'.

	self parse: 'CHOICE {',alternativeTypeList,'}' rule: #choiceType.
	self parse: 'CHOICE {',alternativeTypeList,',... }' rule: #choiceType.
	self parse: 'CHOICE {',alternativeTypeList,' ... ,',alternativeTypeList,'}' rule: #choiceType.
	self parse: 'CHOICE {', alternativeTypeList,' ... ! Foo:bar','}' rule: #choiceType.

]

{ #category : #tests }
ASN1SyntaxTest >> testChoiceValue [
	self parse: 'local:1' rule: #choiceValue.
]

{ #category : #tests }
ASN1SyntaxTest >> testClassWithMultipleConstraints [
	self parse: 'TelephonyString ::=
  IA5String
    (FROM ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "*" |
           "#"))(SIZE (1..15))' rule: #assignmentList.
]

{ #category : #tests }
ASN1SyntaxTest >> testComponentRelationConstraint [
	self parse: '{Operations}{@opcode}' rule: #componentRelationConstraint.

]

{ #category : #tests }
ASN1SyntaxTest >> testComponentType [
	self parse: 'name Name' rule: #componentType.
	self parse: 'name Name' rule: #componentType.
	self parse: 'name Name OPTIONAL' rule: #componentType.
	self parse: 'name Name DEFAULT {}' rule: #componentType.
	self parse: 'COMPONENTS OF Foo' rule: #componentType.
]

{ #category : #tests }
ASN1SyntaxTest >> testComponentTypeList [
	self parse: 'name Name, foo Bar' rule: #componentTypeList.
	self parse: 'name Name ,foo Bar' rule: #componentTypeList.
	self parse: 'name Name   ,    foo Bar' rule: #componentTypeList.
	self parse: 'name Name,foo Bar,peng Zonk' rule: #componentTypeList.
	self fail: 'name Name, foo bar' rule: #componentTypeList.

]

{ #category : #tests }
ASN1SyntaxTest >> testComponentTypeLists [
	self parse: 'name Name, foo Bar' rule: #componentTypeLists.
	self parse: 'name Name, foo Bar, ...' rule: #componentTypeLists.
	self parse: 'name Name, foo Bar, ..., bname Bname' rule: #componentTypeLists.
	self parse: 'name Name, foo Bar, ..., bname Bname, [[ first Second ]]' rule: #componentTypeLists.
	self parse: 'name Name, foo Bar, ..., bname Bname, [[ first Second ]], ...' rule: #componentTypeLists.
	self parse: '..., bname Bname, [[ first Second ]], ..., name Name, foo Bar' rule: #componentTypeLists.
	self parse: '..., bname Bname, [[ first Second ]], ...' rule: #componentTypeLists.

]

{ #category : #tests }
ASN1SyntaxTest >> testComponentValueList [
	self parse: 'foo bar, bar foo, foor bar' rule: #componentValueList.

]

{ #category : #tests }
ASN1SyntaxTest >> testConstrainedType [
	self parse: 'INTEGER   (0 | 8..20)' rule: #type.

]

{ #category : #tests }
ASN1SyntaxTest >> testConstraint [
	self parse: '(SIZE(0..4))' rule: #constraint.

]

{ #category : #tests }
ASN1SyntaxTest >> testContainedSubtype [
	self parse: 'INCLUDES Divisors-of-6' rule: #containedSubtype.

]

{ #category : #tests }
ASN1SyntaxTest >> testContentsConstraint [
	self parse: 'CONTAINING Foo' rule: #contentsConstraint.
	self parse: 'ENCODED BY local:1' rule: #contentsConstraint.
	self parse: 'CONTAINING Foo ENCODED BY local:1' rule: #contentsConstraint.

]

{ #category : #tests }
ASN1SyntaxTest >> testDefaultSyntax [
	self parse: '{
&ArgumentType Matrix,
&ResultType  Matrix, 
&Errors {determinantIsZero},
&operationCode 7
}' rule: #defaultSyntax
]

{ #category : #tests }
ASN1SyntaxTest >> testDefinedObjectClass [
	self parse: 'FOO-BAR' rule: #definedObjectClass
]

{ #category : #tests }
ASN1SyntaxTest >> testDefinedSyntax [
	self parse: '{
ARGUMENT  Matrix 
RESULT       Matrix 
ERRORS       {determinantIsZero} 
CODE          7 }' rule: #definedSyntax
]

{ #category : #tests }
ASN1SyntaxTest >> testDefinedType [
	self parse: 'TCMessage{{Supported-MAP-Operations}, {Supported-MAP-Operations}}' rule: #definedType.
	self parse: 'Foo.Bar' rule: #definedType.
	self parse: 'TCMessage' rule: #definedType
]

{ #category : #tests }
ASN1SyntaxTest >> testDefinedValue [
	self parse: 'Abc.def' rule: #definedValue.
	self parse: 'def' rule: #definedValue.
	self parse: 'Abc-def.hig-plo2' rule: #definedValue.
	self fail: 'Abc' rule: #definedValue.
	self fail: '' rule: #definedValue

]

{ #category : #tests }
ASN1SyntaxTest >> testDefinitiveIdentification [
	self parse: '{itu-t recommendation q 775 modules(2) examples(2) version1(1)}' rule: #definitiveIdentification
	
]

{ #category : #tests }
ASN1SyntaxTest >> testDefinitiveNameAndNumberForm [
	self parse: 'itu-t(34)' rule: #definitiveNameAndNumberForm.

]

{ #category : #tests }
ASN1SyntaxTest >> testDefinitiveObjIdComponent [
	self parse: 'itu-t' rule: #definitiveObjIdComponent.
	self parse: '34' rule: #definitiveObjIdComponent.
	self parse: 'itu-t(34)' rule: #definitiveObjIdComponent.

]

{ #category : #tests }
ASN1SyntaxTest >> testDefinitiveOid [
	| parsed |
	parsed := self parse: '{itu-t recommendation q 775 modules(2) examples(2) version1(1)}' rule: #definitiveOid.
	self assert: parsed size =7
]

{ #category : #tests }
ASN1SyntaxTest >> testElementSetSpec [
	self parse: 'updateLocation | cancelLocation | purgeMS | sendIdentification | updateGprsLocation | prepareHandover | sendEndSignal' rule: #elementSetSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testElementSetSpecs [
	| setSpec |
	setSpec := 'updateLocation | cancelLocation | purgeMS'.
	self parse: setSpec rule: #elementSetSpecs.
	self parse: setSpec, ', ...' rule: #elementSetSpecs.
	self parse: setSpec, ', ..., ',setSpec rule: #elementSetSpecs.


]

{ #category : #tests }
ASN1SyntaxTest >> testElements [
	self parse: '1..2' rule: #elements.
	self parse: '( updateLocation | fooBar )' rule: #elements.


]

{ #category : #tests }
ASN1SyntaxTest >> testEncodingPrefixedType [
	self parse: '[ABC:foobar] FooBar' rule: #encodingPrefixedType.

]

{ #category : #tests }
ASN1SyntaxTest >> testEncodingReference [
	self parse: 'ABC:' rule: #encodingReference.
	self parse: 'FOO-3BAR:' rule: #encodingReference.
	self parse: '' rule: #encodingReference.
	self fail: 'AbC:' rule: #encodingReference.
	self fail: 'A3D-4d:' rule: #encodingReference.
	self fail: 'ABC-:' rule: #encodingReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testEncodingReferenceDefault [
	self parse: 'ABC:INSTRUCTIONS' rule: #encodingReferenceDefault.
	self parse: 'FOO-3BAR:INSTRUCTIONS' rule: #encodingReferenceDefault.
	self parse: '' rule: #encodingReferenceDefault.

]

{ #category : #tests }
ASN1SyntaxTest >> testEnumeratedType [
	self parse: 'ENUMERATED {fdd(0), tdd(1)}' rule: #enumeratedType.

]

{ #category : #tests }
ASN1SyntaxTest >> testEnumeration [
	self parse: 'foo,bar(2),hello' rule: #enumeration.

]

{ #category : #tests }
ASN1SyntaxTest >> testEnumerations [
	self parse: 'foo,bar(2),hello' rule: #enumerations.
	self parse: 'foo,bar(2),hello, ...' rule: #enumerations.
	self flag: #needsRedesign.
	"need to check why the implementation of enumerations had exclusions in them"
	"self parse: 'foo,bar(2),hello, ... !Foo:bar' rule: #enumerations.
	self parse: 'foo,bar(2),hello, ... !Foo:bar, one, two , three(3)' rule: #enumerations."

]

{ #category : #tests }
ASN1SyntaxTest >> testExceptionIdentification [
	self parse: '-234' rule: #exceptionIdentification.
	self parse: 'abc' rule: #exceptionIdentification.
	self parse: 'Foo.abc' rule: #exceptionIdentification.
	self parse: 'Foo:abc' rule: #exceptionIdentification.

]

{ #category : #tests }
ASN1SyntaxTest >> testExceptionSpec [
	self parse: '! -234' rule: #exceptionSpec.
	self parse: '! Foobar:xyz' rule: #exceptionSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testExclusions [
	self parse: 'EXCEPT 1..3' rule: #exclusions.

]

{ #category : #tests }
ASN1SyntaxTest >> testExports [
	self parse: 'EXPORTS
        cancel, 
        cancelFailed, 
        cancelled
;' rule: #exports.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAddition [
	self parse: 'name Name' rule: #extensionAddition.
	self parse: '[[ name Name, foo Bar]]' rule: #extensionAddition.
	self parse: '[[ 456: name Name, foo Bar ]]' rule: #extensionAddition.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditionAlternative [
	self parse: 'name Name' rule: #extensionAddition.
	self parse: '[[ name Name, foo Bar]]' rule: #extensionAddition.
	self parse: '[[ 456: name Name, foo Bar ]]' rule: #extensionAddition.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditionAlternatives [
	self parse: ',name Name, foo Bar' rule: #extensionAdditionAlternatives.
	self parse: ',[[ name Name, foo Bar]]' rule: #extensionAdditionAlternatives.
	self parse: ',[[ 456: name Name, foo Bar ]], [[ 456: name Name, foo Bar ]]' rule: #extensionAdditionAlternatives.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditionAlternativesGroup [
	self parse: '[[ name Name, foo Bar]]' rule: #extensionAdditionGroup.
	self parse: '[[ 456: name Name, foo Bar ]]' rule: #extensionAdditionGroup.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditionAlternativesList [
	self parse: 'name Name, foo Bar' rule: #extensionAdditionAlternativesList.
	self parse: '[[ name Name, foo Bar]]' rule: #extensionAdditionAlternativesList.
	self parse: '[[ 456: name Name, foo Bar ]], [[ 456: name Name, foo Bar ]]' rule: #extensionAdditionAlternativesList.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditionGroup [
	self parse: '[[ name Name, foo Bar]]' rule: #extensionAdditionGroup.
	self parse: '[[ 456: name Name, foo Bar ]]' rule: #extensionAdditionGroup.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditionList [
	self parse: 'name Name, foo Bar' rule: #extensionAdditionList.
	self parse: '[[ name Name, foo Bar]]' rule: #extensionAdditionList.
	self parse: '[[ 456: name Name, foo Bar ]], [[ 456: name Name, foo Bar ]]' rule: #extensionAdditionList.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAdditions [
	self parse: ', name Name' rule: #extensionAdditions.
	self parse: ', [[ name Name, foo Bar]]' rule: #extensionAdditions.
	self parse: ',[[ 456: name Name, foo Bar ]]' rule: #extensionAdditions.
	self parse: '' rule: #extensionAdditions.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionAndException [
	self parse: '...' rule: #extensionAndException.
	self parse: '... ! Foo:bar' rule: #extensionAndException.

]

{ #category : #tests }
ASN1SyntaxTest >> testExtensionEndMarker [
	self parse: ', ...' rule: #extensionEndMarker.
]

{ #category : #tests }
ASN1SyntaxTest >> testExternalObjectClassReference [
	self parse: 'Foobar.FOOBAR' rule: #externalObjectClassReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testExternalObjectSetReference [
	self parse: 'Foobar.FOOBAR' rule: #externalObjectSetReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testExternalTypeReference [
	self parse: 'Foobar.FOOBAR' rule: #externalTypeReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testExternalValueReference [
	self parse: 'Abc.def' rule: #externalValueReference.
	self parse: 'Abc-def.hig-plo2' rule: #externalValueReference.
	self fail: 'abc' rule: #externalValueReference.
	self fail: 'abc.def' rule: #externalValueReference.
	self fail: 'Abc.Def' rule: #externalValueReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testFieldName [
	self parse: '&ArgumentType' rule: #fieldName.
	self parse: '&Errors.&Parameter' rule: #fieldName.
	self parse: '&Errors.&errorCode' rule: #fieldName.
	self parse: '&Linked.&ArgumentType' rule: #fieldName.
	self parse: '&Linked.&Linked.&operationCode' rule: #fieldName.
	self parse: '&Linked.&Linked.&Linked.&Linked.&Linked.&Errors.&errorCode' rule: #fieldName.
 
]

{ #category : #tests }
ASN1SyntaxTest >> testFieldSpec [
	self parse: '&Errors                ERROR OPTIONAL' rule: #fieldSpec.
	self parse: '&argumentTypeOptional  BOOLEAN OPTIONAL' rule: #fieldSpec.
	self parse: '&ArgumentType          OPTIONAL' rule: #fieldSpec.
]

{ #category : #tests }
ASN1SyntaxTest >> testFixedTypeValueFieldSpec [
	self parse: '&operationCode         Code UNIQUE OPTIONAL' rule: #fixedTypeValueFieldSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testFixedTypeValueSetFieldSpec [
	self parse: '&Errors                ERROR OPTIONAL' rule: #fixedTypeValueSetFieldSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testFullSpecification [
	self parse: '{ foobar OPTIONAL, bogus PRESENT }' rule: #fullSpecification.
	self parse: '{ foobar (1..2) ABSENT, vague (SIZE(16)) OPTIONAL }' rule: #fullSpecification.

]

{ #category : #tests }
ASN1SyntaxTest >> testGlobalModuleReference [
	self parse: 'Foo { one two three }' rule: #globalModuleReference
]

{ #category : #tests }
ASN1SyntaxTest >> testGovernor [
	self parse: 'Foo' rule: #governor.
	self parse: 'FOO' rule: #governor.
]

{ #category : #tests }
ASN1SyntaxTest >> testHString [
	self parse: '''0010011''H' rule: #hString.
	self parse: '''001 00
	11''H' rule: #hString.
	self parse: '''DEADBEEF''H' rule: #hString.
	self fail: '''DEAD BEEF''' rule: #hString.
	self fail: '''DEADBEEFH' rule: #hString.
	self fail: 'DEADBEEF''H' rule: #hString.
	
	self assert: (self parse: '''DEADBEEF''H' rule: #hString) = 'DEADBEEF'
]

{ #category : #tests }
ASN1SyntaxTest >> testIdentifier [
	self parse: 'a' rule: #identifier.
	self parse: 'local' rule: #identifier.
	self parse: 'abc' rule: #identifier.
	self parse: 'aBc-def' rule: #identifier.
	self parse: 'abc-Def34' rule: #identifier.
	self parse: 'b-A' rule: #identifier.
	self fail: '' rule: #identifier.
	self fail: 'Abc' rule: #identifier.
	self fail: 'abc-def-' rule: #identifier.
	self flag: #needsThinking.
	"this test fails if identifiers are parsed as tokens. This introduces the possibility that a 
	-- is treated as the start of a comment which prevents to token parser to fail. From the
	standard it reads as this is exactly the case why -- is forbidden. So we should be safe
	here"
	"self fail: 'abc--def' rule: #identifier."
	self fail: 'local:' rule: #identifier.
	
	self assert: (self parse: 'abc-Def34' rule: #identifier) value = 'abc-Def34'
]

{ #category : #tests }
ASN1SyntaxTest >> testIdentifierList [
	self parse: 'a' rule: #identifierList.
	self parse: 'abc' rule: #identifierList.
	self parse: 'aBc,def' rule: #identifierList.
	self parse: 'abc,def34,def' rule: #identifierList.
	self fail: 'abc,Def34,def' rule: #identifierList.
	
	self assert: (self parse: 'abc,def,ghj'  rule: #identifierList) = #( 'abc' 'def' 'ghj' )
]

{ #category : #tests }
ASN1SyntaxTest >> testImports [
	self parse: 'IMPORTS
  OPERATION, ERROR
    FROM Remote-Operations-Information-Objects {joint-iso-itu-t
      remote-operations(4) informationObjects(5) version1(0)};' rule: #imports.

]

{ #category : #tests }
ASN1SyntaxTest >> testInnerTypeConstraints [
	self parse: 'WITH COMPONENTS (1..8)' rule: #innerTypeConstraints
]

{ #category : #tests }
ASN1SyntaxTest >> testInstanceOfType [
	self parse: 'INSTANCE OF FOO' rule: #instanceOfType
]

{ #category : #tests }
ASN1SyntaxTest >> testIntegerType [
	self parse: 'INTEGER { a(2) }' rule: #integerType.
	self parse: 'INTEGER{   b(3),  h(a)     }' rule: #integerType.
	self parse: 'INTEGER ' rule: #integerType.
	self fail: '' rule: #integerType.

]

{ #category : #tests }
ASN1SyntaxTest >> testIntegerValue [
	self parse: '-15' rule: #integerValue.
	self parse: 'foobar' rule: #integerValue.
]

{ #category : #tests }
ASN1SyntaxTest >> testIntersections [
	self parse: '1 ^ 2' rule: #intersections.
	self parse: '1 ^ 2 .. 83' rule: #intersections.

]

{ #category : #tests }
ASN1SyntaxTest >> testLiteral [
	self parse: 'A' rule: #literal.
	self parse: 'ABC' rule: #literal.
	self parse: 'ABC-DEF' rule: #literal.
	self parse: 'AB-CD-EF' rule: #literal.
	self parse: ',' rule: #literal.
	self fail: '-ABC' rule: #literal.
	self fail: 'ABC-' rule: #literal.
	self fail: 'ABC-d' rule: #literal.

]

{ #category : #tests }
ASN1SyntaxTest >> testLowerEndPoint [
	self parse: '2' rule: #lowerEndPoint.
	self parse: 'foobar' rule: #lowerEndPoint.
	self parse: 'MIN' rule: #lowerEndPoint.
	self parse: '2<' rule: #lowerEndPoint
]

{ #category : #tests }
ASN1SyntaxTest >> testModuleBody [
	self parse: '' rule: #moduleBody.
	self parse: 'IMPORTS
  ROS{}, InvokeId
    FROM Remote-Operations-Generic-ROS-PDUs {joint-iso-itu-t
      remote-operations(4) generic-ROS-PDUs(6) version1(0)}
  OPERATION
    FROM Remote-Operations-Information-Objects {joint-iso-itu-t
      remote-operations(4) informationObjects(5) version1(0)}
  Supported-MAP-Operations
    FROM MAP-Protocol {itu-t identified-organization (4) etsi (0) mobileDomain (0)
   	 gsm-Network (1) modules (3) map-Protocol (4) version12 (12)}
-- Start - Added by Eranga
  dialogue-as-id
    FROM DialoguePDUs {itu-t recommendation q 773 modules(2) dialoguePDUs(2)
      version1(1)}
  sendRoutingInfoForSM,
  mo-ForwardSM,
  mt-ForwardSM,
  reportSM-DeliveryStatus,
  alertServiceCentre,
  informServiceCentre,
  readyForSM
	FROM MAP-ShortMessageServiceOperations {
	   itu-t identified-organization (4) etsi (0) mobileDomain (0)
	   gsm-Network (1) modules (3) map-ShortMessageServiceOperations (9)
	   version12 (12)}
  gsm-MessagingId
  	FROM MobileDomainDefinitions {
	   itu-t identified-organization (4) etsi (0) mobileDomain (0)
	   mobileDomainDefinitions (0) version1 (1)}
  Supported-MAP-Operations
  	FROM MAP-Protocol {
	   itu-t identified-organization (4) etsi (0) mobileDomain (0)
	   gsm-Network (1) modules (3) map-Protocol (4) version12 (12)}
-- End - Added by Eranga
;

-- Start - Added by Eranga

mapSpecificAS ABSTRACT-SYNTAX ::= {
  MapSpecificPDUs
  IDENTIFIED BY  gsm-MessagingId
}

MapSpecificPDUs ::=
  TCMessage{{Supported-MAP-Operations}, {Supported-MAP-Operations}}


MAPOperations-Invokable OPERATION ::= 
	{sendRoutingInfoForSM | mo-ForwardSM | mt-ForwardSM} 
MAPOperations-Returnable OPERATION ::= 
	{reportSM-DeliveryStatus | alertServiceCentre | informServiceCentre | readyForSM} 

-- End - Added by Eranga


TCMessage{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  unidirectional  [APPLICATION 1]  Unidirectional{{Invokable}, {Returnable}},
  begin           [APPLICATION 2]  Begin{{Invokable}, {Returnable}},
  end             [APPLICATION 4]  End{{Invokable}, {Returnable}},
  continue        [APPLICATION 5]  Continue{{Invokable}, {Returnable}},
  abort           [APPLICATION 7]  Abort
}

Unidirectional{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}}
}

Begin{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  otid             OrigTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}

End{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  dtid             DestTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}

Continue{OPERATION:Invokable, OPERATION:Returnable} ::= SEQUENCE {
  otid             OrigTransactionID,
  dtid             DestTransactionID,
  dialoguePortion  DialoguePortion OPTIONAL,
  components       ComponentPortion{{Invokable}, {Returnable}} OPTIONAL
}

Abort ::= SEQUENCE {
  dtid    DestTransactionID,
  reason  CHOICE {p-abortCause  P-AbortCause,
                  u-abortCause  DialoguePortion} OPTIONAL
}

-- NOTE - When the Abort Message is generated by the Transaction sublayer, a p-Abort Cause may be 
-- present. The u-abortCause may be generated by the component sublayer in which case it is an ABRT 
-- APDU, or by the TC-User in which case it could be either an ABRT APDU or data in some user-defined
-- abstract syntax.
DialoguePortion ::= [APPLICATION 11] EXPLICIT EXTERNAL

-- The dialogue portion carries the dialogue control PDUs as value of the external data type. The direct 
-- reference should be set to {itu-t recommendation q 773 as(1) dialogue-as(1) version1(1)} if structured 
-- dialogue is used and to {itu-t recommendation q 773 as(1) unidialogue-as(2) version1(1)} if unstructured 
-- dialogue is used.
OrigTransactionID ::= [APPLICATION 8]  OCTET STRING(SIZE (1..4))

DestTransactionID ::= [APPLICATION 9]  OCTET STRING(SIZE (1..4))

P-AbortCause ::= [APPLICATION 10]  INTEGER {
  unrecognizedMessageType(0), unrecognizedTransactionID(1),
  badlyFormattedTransactionPortion(2), incorrectTransactionPortion(3),
  resourceLimitation(4)}(0..127)

-- COMPONENT PORTION. The last field in the transaction portion of the TCAP message is the 
-- component portion. The component portion may be absent.
ComponentPortion{OPERATION:Invokable, OPERATION:Returnable} ::=
  [APPLICATION 12] 
    SEQUENCE SIZE (1..MAX) OF Component{{Invokable}, {Returnable}}

-- Component Portion fields
-- Recommendation X.880 defines four Application Protocol Data Units (APDUs) for invoking
-- operations, returning results or error, and for the rejection of invalid PDUs.
-- TCAP adds returnResultNotLast to allow for the segmentation of a result.
Component{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  basicROS             ROS{{TCInvokeIdSet}, {Invokable}, {Returnable}},
  returnResultNotLast
    [7]  returnResult < ROS{{TCInvokeIdSet}, {Invokable}, {Returnable}}
}

TCInvokeIdSet ::= InvokeId(WITH COMPONENTS {
                             present  (-128..127)
                           })' rule: #moduleBody
]

{ #category : #tests }
ASN1SyntaxTest >> testModuleDefinition [
	self parse:  self class moduleDefinition rule: #moduleDefinition
]

{ #category : #tests }
ASN1SyntaxTest >> testModuleIdentifier [
	self parse: 'TCAP-Examples {itu-t recommendation q 775 modules(2) examples(2) version1(1)}' rule: #moduleIdentifier.
	self parse: '-- Generated by Asnp, the pretty-printer of France Telecom R&D (http://asn1.elibel.tm.fr/asnp/)
-- Module TCAPMessages (Q.773:06/1997)
-- asn1ct:compile("TCAPMessages",[ber_bin]).
TCAPMessages {itu-t recommendation q 773 modules(2) messages(1) version3(3)}
' rule: #moduleIdentifier

]

{ #category : #tests }
ASN1SyntaxTest >> testNameAndNumberForm [
	
	self assert: (self parse: 'modules(3)' rule: #nameAndNumberForm) = #( 'modules' '3' )
]

{ #category : #tests }
ASN1SyntaxTest >> testNamedBit [
	self parse: 'hello (0)' rule: #namedBit.

]

{ #category : #tests }
ASN1SyntaxTest >> testNamedBitList [
	self parse: 'foobar(15), barfoo(16), lolo(18)' rule: #namedBitList

]

{ #category : #tests }
ASN1SyntaxTest >> testNamedConstraint [
	self parse: 'foobar OPTIONAL' rule: #namedConstraint.
	self parse: 'foobar (1..2) ABSENT' rule: #namedConstraint.
	self parse: 'foobar (SIZE(4)) PRESENT' rule: #namedConstraint.

]

{ #category : #tests }
ASN1SyntaxTest >> testNamedNumber [
	self parse: 'abc ( 153 )' rule: #namedNumber.
	self parse: 'abc ( -32 )' rule: #namedNumber.
	self parse: 'abc( foobar)' rule: #namedNumber.
	self fail: '' rule: #namedNumber.
	self fail: 'abc ( 8' rule: #namedNumber.

]

{ #category : #tests }
ASN1SyntaxTest >> testNamedNumberList [
	self parse: 'abc ( 153 ), def(178)' rule: #namedNumberList.
	self parse: 'abc ( -32 )   ,xyz(178178),foobar( hallo     )' rule: #namedNumberList.
	self fail: '' rule: #namedNumberList.
	self fail: 'abc (8) def(9)' rule: #namedNumberList.
	self fail: 'abc (8), def(9),' rule: #namedNumberList.

]

{ #category : #tests }
ASN1SyntaxTest >> testNamedValue [
	self parse: 'foo bar' rule: #namedValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testNamedValueList [
	self parse: 'foo bar, bar foo, foor bar' rule: #namedValueList.

]

{ #category : #tests }
ASN1SyntaxTest >> testNumber [
	self parse: '1' rule: #number.
	self parse: '1362763728' rule: #number.
	self fail: '-136' rule: #number.
	self fail: 'abc' rule: #number.
	self fail: ' abc ' rule: #number.
	self fail: '' rule: #number
]

{ #category : #tests }
ASN1SyntaxTest >> testNumericRealValue [
	self parse: '1.456789e-10' rule: #numericRealValue.
	self parse: '-1.E-10' rule: #numericRealValue.
	self parse: '{}' rule: #numericRealValue
]

{ #category : #tests }
ASN1SyntaxTest >> testObject [
	self parse: '{ 
	ARGUMENT 	INTEGER
	ERRORS 	{ { PARAMETER INTEGER CODE 1000 } | { CODE 1001 } }
	CODE 		1 }' rule: #object.
	self parse: '{CODE  local:1}' rule: #object.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectAssignment [
	self parse: 'mapSpecificAS ABSTRACT-SYNTAX ::= {
  MapSpecificPDUs
  IDENTIFIED BY  gsm-MessagingId
}' rule: #objectAssignment.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectClassAssignment [
	self parse: 'FOOBAR ::= CLASS {&ArgumentType OPTIONAL}' rule: #objectClassAssignment.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectClassDefn [
	self parse: 'CLASS {
  &ArgumentType          OPTIONAL,
  &argumentTypeOptional  BOOLEAN OPTIONAL
}' rule: #objectClassDefn.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectClassFieldType [
	self parse: 'FOOBAR.&fooBar' rule: #objectClassFieldType.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectClassReference [
	
	self parse: 'FOOBAR' rule: #objectClassReference.
	self parse: 'FOOBAR-FOO' rule: #objectClassReference.
	self fail: 'FOOBAR-' rule: #objectClassReference.
	self fail: 'FooBAR' rule: #objectClassReference
]

{ #category : #tests }
ASN1SyntaxTest >> testObjectFieldReference [
	self parse: '&fooBar' rule: #objectFieldReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectFieldSpec [
	self parse: '&fooBar FOOBAR' rule: #objectFieldSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectFromObject [
	self parse: 'fooBar.&fooBar' rule: #objectFromObject.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectIdentifierType [
	
	self parse: 'OBJECT IDENTIFIER' rule: #objectIdentifierType
]

{ #category : #tests }
ASN1SyntaxTest >> testObjectIdentifierValue [
	
	self parse: '{ joint-iso-itu-t module(3) }' rule: #objectIdentifierValue
]

{ #category : #tests }
ASN1SyntaxTest >> testObjectOptionalitySpec [
	self parse: 'OPTIONAL' rule: #objectOptionalitySpec.
	self parse: 'DEFAULT foobar' rule: #objectOptionalitySpec.


]

{ #category : #tests }
ASN1SyntaxTest >> testObjectReference [
	self parse: 'mapSpecificAS' rule: #objectReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSet [
	self parse: '{a | b | c}' rule: #objectSet.
	self parse: '{ ... }' rule: #objectSet.
	self parse: '{ a | b | c, ..., d | e | f }' rule: #objectSet.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetAssignment [
	self parse: 'Foobar FOOBAR ::= { 1..2 }' rule: #objectSetAssignment.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetElements [
	self parse: '{ Foobar }' rule: #objectSetElements.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetFieldReference [
	self parse: '&Foobar' rule: #objectSetFieldReference.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetFieldSpec [
	self parse: '&Foobar FOOBAR' rule: #objectSetFieldSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetFromObjects [
	self parse: 'foobar.&Foobar' rule: #objectSetFromObjects.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetOptionality [
	self parse: 'OPTIONAL' rule: #objectSetOptionality.
	self parse: 'DEFAULT { a | b | c }' rule: #objectSetOptionality.

]

{ #category : #tests }
ASN1SyntaxTest >> testObjectSetSpec [
	self parse: 'a | b | c' rule: #objectSetSpec.
	self parse: 'a | b | c, ...' rule: #objectSetSpec.
	self parse: '...' rule: #objectSetSpec.
	self parse: '..., a | b | c' rule: #objectSetSpec.
	self parse: 'a | b | c, ..., d | e | f' rule: #objectSetSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testOctetStringValue [
	self parse: '''010101''B' rule: #bitStringValue.
	self parse: '''DEADBEEF''H' rule: #bitStringValue.
	self parse: 'CONTAINING foo' rule: #bitStringValue.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testOpenTypeFieldVal [
	self parse: 'Foobar:foobar' rule: #openTypeFieldVal.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testOptionalExtensionMarker [
	self parse: ',...' rule: #optionalExtensionMarker.
	self parse: ',   ...' rule: #optionalExtensionMarker.

]

{ #category : #tests }
ASN1SyntaxTest >> testOptionalGroup [
	self parse: '[ FOOBAR ]' rule: #optionalGroup.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testParamGovernor [
	self parse: 'FooBar' rule: #paramGovernor.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testParameter [
	self parse: 'OPERATION:Invokable' rule: #parameter.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterList [
	self parse: '{OPERATION:Invokable}' rule: #parameterList.	
	self parse: '{OPERATION:Invokable,OPERATION:Foo}' rule: #parameterList.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedAssignment [
	self parse: 'TCMessage{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  unidirectional  [APPLICATION 1]  Unidirectional{{Invokable}, {Returnable}},
  begin           [APPLICATION 2]  Begin{{Invokable}, {Returnable}},
  end             [APPLICATION 4]  End{{Invokable}, {Returnable}},
  continue        [APPLICATION 5]  Continue{{Invokable}, {Returnable}},
  abort           [APPLICATION 7]  Abort
}
' rule: #parameterizedAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedObject [
	self parse: 'foobar{Foobar}' rule: #parameterizedObject
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedObjectAssignment [
	self parse: 'foobar{Foobar}  FOOBAR ::=  foobar' rule: #parameterizedObjectAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedObjectClass [
	self parse: 'FOOBAR{Foobar}' rule: #parameterizedObjectClass
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedObjectClassAssignment [
	self parse: 'FOOBAR{Foobar}  ::= FOOBAR' rule: #parameterizedObjectClassAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedObjectSet [
	self parse: 'Foobar{Foobar}' rule: #parameterizedObjectSet
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedObjectSetAssignment [
	self parse: 'Foobar{Foobar}  FOOBAR ::=  { 1..2 }' rule: #parameterizedObjectSetAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedReference [
	self parse: 'Foobar{}' rule: #parameterizedReference
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedType [
	self parse: 'Foobar{Foobar}' rule: #parameterizedType
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedTypeAssignment [
	self parse: 'ComponentPortion{OPERATION:Invokable, OPERATION:Returnable} ::= CHOICE {
  bla BLUBB
}' rule: #parameterizedTypeAssignment.
	self parse: 'ComponentPortion{OPERATION:Invokable, OPERATION:Returnable} ::=
  [APPLICATION 12] 
    SEQUENCE SIZE (1..MAX) OF Component{{Invokable}, {Returnable}}' rule: #parameterizedTypeAssignment.
self parse: 'ComponentPortion{OPERATION:Invokable, OPERATION:Returnable} ::=
  [APPLICATION 12] 
    SEQUENCE SIZE (1..MAX) OF Component{{Invokable}, {Returnable}}' rule: #parameterizedAssignment
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedValue [
	self parse: 'foo{Bar}' rule: #parameterizedValue.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedValueAssignment [
	self parse: 'foobar{Foobar} Foobar ::= foobar' rule: #parameterizedValueAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedValueSetType [
	self parse: 'Foobar{Foobar}' rule: #parameterizedValueSetType
]

{ #category : #tests }
ASN1SyntaxTest >> testParameterizedValueSetTypeAssignment [
	self parse: 'Foobar{Foobar} Foobar ::= { 1..2 }' rule: #parameterizedValueSetTypeAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testPartialSpecification [
	self parse: '{ ..., foobar ABSENT}' rule: #partialSpecification.
	self parse: '{ ..., foobar (SIZE(4)) ABSENT}' rule: #partialSpecification
]

{ #category : #tests }
ASN1SyntaxTest >> testPatternConstraint [
	self parse: 'PATTERN foobaar' rule: #patternConstraint.

]

{ #category : #tests }
ASN1SyntaxTest >> testPrefixedType [
	self parse: '[APPLICATION 2] IMPLICIT Foobar' rule: #prefixedType.
	self parse: '[0] IMPLICIT IsdnNumber' rule: #prefixedType.

]

{ #category : #tests }
ASN1SyntaxTest >> testPrimitiveFieldName [
	self parse: '&fooBar' rule: #primitiveFieldName.
	self parse: '&FooBar' rule: #primitiveFieldName.


]

{ #category : #tests }
ASN1SyntaxTest >> testPropertySettings [
	self parse: 'SETTINGS "foobar"' rule: #propertySettings.

]

{ #category : #tests }
ASN1SyntaxTest >> testQuadruple [
	self parse: '{ 12, 48, 34, 189}' rule: #quadruple.

]

{ #category : #tests }
ASN1SyntaxTest >> testRealNumber [
	self parse: '1.456789e-10' rule: #realNumber.
	self parse: '1.E-10' rule: #realNumber
]

{ #category : #tests }
ASN1SyntaxTest >> testRealValue [
	self parse: 'PLUS-INFINITY' rule: #realValue.
	self parse: 'NOT-A-NUMBER' rule: #realValue.
	self parse: '-13' rule: #realValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testReference [
	self parse: 'Foobar' rule: #reference.
	self parse: 'foobar' rule: #reference.
	self parse: 'FOOBAR' rule: #reference.

]

{ #category : #tests }
ASN1SyntaxTest >> testReferencedObjects [
	self parse: 'foobar' rule: #referencedObjects.
	self parse: 'Foobar' rule: #referencedObjects.

]

{ #category : #tests }
ASN1SyntaxTest >> testReferencedType [
	self parse: 'Foobar' rule: #referencedType.
	self parse: 'foobar<Foobar' rule: #referencedType.
	self parse: 'Foobar.&foobar' rule: #referencedType.
	self parse: 'Foobar.&Foobar' rule: #referencedType.
	self parse: 'FOOBAR' rule: #referencedType.

]

{ #category : #tests }
ASN1SyntaxTest >> testReferencedValue [
	self parse: 'foobar' rule: #referencedValue.
	self parse: 'foobar.&foobar' rule: #referencedValue.
	self parse: 'foobar.&Foobar' rule: #referencedValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testRelativeOidComponents [
	self parse: '1' rule: #relativeOidComponents.
	self parse: 'foo(1)' rule: #relativeOidComponents.
	self parse: 'foo' rule: #relativeOidComponents.

]

{ #category : #tests }
ASN1SyntaxTest >> testRelativeOidValue [
	self parse: '{ foo foo(3) 4}' rule: #relativeOidValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testRequiredToken [
	self parse: 'FOO' rule: #requiredToken.
	self parse: '&Foo' rule: #requiredToken.
	self parse: '&foo' rule: #requiredToken.



]

{ #category : #tests }
ASN1SyntaxTest >> testRestrictedCharacterStringType [
	self parse: 'IA5String' rule: #restrictedCharacterStringType.
	self parse: 'UTF8String' rule: #restrictedCharacterStringType.
	self parse: 'VisibleString' rule: #restrictedCharacterStringType.

]

{ #category : #tests }
ASN1SyntaxTest >> testRestrictedCharacterStringValue [
	self parse: '"hello world"' rule: #restrictedCharacterStringValue.
	self parse: '{ "hello world",{8,9}, abc, Foo.abc }' rule: #restrictedCharacterStringValue.
	self parse: '{8,9,10,11}' rule: #restrictedCharacterStringValue.
	self parse: '{8,9}' rule: #restrictedCharacterStringValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testSelectionType [
	self parse: 'present < TCInvokeIdSet' rule: #selectionType.
]

{ #category : #tests }
ASN1SyntaxTest >> testSequenceOfType [
	self parse: 'SEQUENCE OF Foo' rule: #sequenceOfType.
	self parse: 'SEQUENCE OF foo Foo' rule: #sequenceOfType.

]

{ #category : #tests }
ASN1SyntaxTest >> testSequenceOfValue [
	self parse: '{}' rule: #sequenceOfValue.
	self parse: '{ 1,2,3,4,5,6,7 }' rule: #sequenceOfValue.
	self parse: '{ abc, def ,ghi }' rule: #sequenceOfValue.


]

{ #category : #tests }
ASN1SyntaxTest >> testSequenceType [
	self parse: 'SEQUENCE {}' rule: #sequenceType.
	self parse: 'SEQUENCE { name Name }' rule: #sequenceType.
	self parse: 'SEQUENCE { ... }' rule: #sequenceType.
	self parse: 'SEQUENCE { ... ! Foo:bar}' rule: #sequenceType.
	self parse: 'SEQUENCE { ... ! Foo:bar, ... }' rule: #sequenceType.
	self parse: 'SEQUENCE {
  calledNumber  IsdnNumber,
  basicService  BasicServiceIndicator OPTIONAL
}' rule: #sequenceType

]

{ #category : #tests }
ASN1SyntaxTest >> testSetOfType [
	self parse: 'SET OF Foo' rule: #setOfType.
	self parse: 'SET OF foo Foo' rule: #setOfType.

]

{ #category : #tests }
ASN1SyntaxTest >> testSetOfValue [
	self parse: '{}' rule: #setOfValue.
	self parse: '{ 1,2,3,4,5,6,7 }' rule: #setOfValue.
	self parse: '{ abc, def ,ghi }' rule: #setOfValue.


]

{ #category : #tests }
ASN1SyntaxTest >> testSetType [
	self parse: 'SET {}' rule: #setType.
	self parse: 'SET { name Name }' rule: #setType.
	self parse: 'SET { ... }' rule: #setType.
	self parse: 'SET { ... ! Foo:bar}' rule: #setType.
	self parse: 'SET { ... ! Foo:bar, ... }' rule: #setType.

]

{ #category : #tests }
ASN1SyntaxTest >> testSetValue [
	self parse: '{}' rule: #setValue.
	self parse: '{ foo bar }' rule: #setValue.
	self parse: '{ abc def ,ghi jkl}' rule: #setValue.


]

{ #category : #tests }
ASN1SyntaxTest >> testSetting [
	self parse: 'Foobar' rule: #setting.
	self parse: 'foobar' rule: #setting.
	self parse: '{ abc }' rule: #setting.
	self parse: '{ abc | def }' rule: #setting.


]

{ #category : #tests }
ASN1SyntaxTest >> testSignedNumber [
	self parse: '1' rule: #signedNumber.
	self parse: '1362763728' rule: #signedNumber.
	self parse: '-136' rule: #signedNumber.
	self fail: '- 136' rule: #signedNumber.
	self fail: ' -136' rule: #signedNumber.
	self fail: '' rule: #signedNumber

]

{ #category : #tests }
ASN1SyntaxTest >> testSpecialRealValue [
	self parse: 'PLUS-INFINITY' rule: #specialRealValue.
	self parse: 'NOT-A-NUMBER' rule: #specialRealValue.

]

{ #category : #tests }
ASN1SyntaxTest >> testSubTypeElements [
	self parse: '1..10' rule: #subTypeElements.
	self parse: 'SIZE(4)' rule: #subTypeElements.
]

{ #category : #tests }
ASN1SyntaxTest >> testSymbol [
	self parse: 'OPERATION' rule: #symbol.
	self parse: 'ROS{}' rule: #symbol.
]

{ #category : #tests }
ASN1SyntaxTest >> testSymbolList [
	self parse: 'OPERATION,ERROR' rule: #symbolList.
	self parse: 'ROS{}, InvokeId' rule: #symbolList.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testSymbolsFromModule [
	self parse: 'ROS{}, InvokeId
    FROM Remote-Operations-Generic-ROS-PDUs {joint-iso-itu-t
      remote-operations(4) generic-ROS-PDUs(6) version1(0)}' rule: #symbolsFromModule.

]

{ #category : #tests }
ASN1SyntaxTest >> testSyntaxList [
	self parse: '{ ABC }' rule: #syntaxList.
	self parse: '{
  [PARAMETER &ParameterType
   [OPTIONAL &parameterTypeOptional]]
  [PRIORITY &ErrorPriority]
  [CODE &errorCode]
}' rule: #syntaxList.

]

{ #category : #tests }
ASN1SyntaxTest >> testTString [
	self parse: '"2011-05-29T21:00:00Z"' rule: #tString.

]

{ #category : #tests }
ASN1SyntaxTest >> testTableConstraint [
	self parse: '{ExtensionSet}{@extId}' rule: #tableConstraint
]

{ #category : #tests }
ASN1SyntaxTest >> testTag [
	self parse: '[ TAG:APPLICATION 0]' rule: #tag.
	self parse: '[APPLICATION 1]' rule: #tag.
	self parse: '[1]' rule: #tag.

	self fail: '' rule: #tag.
	self fail: '[]' rule: #tag.
	self fail: '[HALLO 8]' rule: #tag.

]

{ #category : #tests }
ASN1SyntaxTest >> testTagClass [
	self parse: '' rule: #tagClass.
	self parse: 'UNIVERSAL' rule: #tagClass.
	self parse: 'APPLICATION' rule: #tagClass.
	self parse: 'PRIVATE' rule: #tagClass.
	self fail: 'Abc' rule: #tagClass.

]

{ #category : #tests }
ASN1SyntaxTest >> testTagDefault [
	self parse: 'IMPLICIT TAGS' rule: #tagDefault.
	self parse: 'EXPLICIT TAGS' rule: #tagDefault.
	self parse: 'AUTOMATIC TAGS' rule: #tagDefault.
	self parse: '' rule: #tagDefault.

]

{ #category : #tests }
ASN1SyntaxTest >> testTagNumber [
	self parse: '153' rule: #tagNumber.
	self parse: 'abc' rule: #tagNumber.
	self fail: '' rule: #tagNumber.

]

{ #category : #tests }
ASN1SyntaxTest >> testTaggedType [
	self parse: '[APPLICATION 2] IMPLICIT Foobar' rule: #taggedType.
	self parse: '[0] IMPLICIT IsdnNumber' rule: #taggedType.

]

{ #category : #tests }
ASN1SyntaxTest >> testTuple [
	self parse: '{ 12, 48}' rule: #tuple.

]

{ #category : #tests }
ASN1SyntaxTest >> testType [
	self parse: 'Foobar' rule: #type.
	self parse: 'Foobar(Foobar)' rule: #type.
	self parse: 'Foobar(Foobar)' rule: #type.
	
]

{ #category : #tests }
ASN1SyntaxTest >> testTypeAssignment [
	self parse: 'PersonnelRecord ::= [APPLICATION 0] SET { 
		name                  Name,
      	title                    VisibleString,
		number               EmployeeNumber,
		dateOfHire         Date,
		nameOfSpouse   Name,
		children              SEQUENCE OF ChildInformation DEFAULT {}
	}' rule: #typeAssignment.
	
	self parse: 'FrameOffset          ::= INTEGER   (0 | 8..20)' rule: #typeAssignment.
	self parse: 'RlcFrequencyList     ::= SEQUENCE  (SIZE(32)) OF PairOfCarrierFrequencies' rule: #typeAssignment.
	self parse: 'Abort ::= SEQUENCE { dtid    DestTransactionID }' rule: #typeAssignment.
	self parse: 'DialoguePortion ::= [APPLICATION 11] EXPLICIT EXTERNAL' rule: #typeAssignment.
	self parse: 'OrigTransactionID ::= [APPLICATION 8]  OCTET STRING(SIZE (1..4))' rule: #typeAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testTypeConstraints [
	self parse: 'foobar OPTIONAL, bogus PRESENT' rule: #typeConstraints.
	self parse: 'foobar (1..2) ABSENT, vague (SIZE(16)) OPTIONAL' rule: #typeConstraints.

]

{ #category : #tests }
ASN1SyntaxTest >> testTypeFieldReference [
	self parse: '&Errors' rule: #typeFieldReference.
	self fail: '&argumentTypeOptional' rule: #typeFieldReference.
]

{ #category : #tests }
ASN1SyntaxTest >> testTypeFieldSpec [
	self parse: '&ArgumentType          OPTIONAL' rule: #typeFieldSpec.

]

{ #category : #tests }
ASN1SyntaxTest >> testTypeFromObject [
	self parse: 'OPERATION.&operationCode' rule: #typeFromObject.


]

{ #category : #tests }
ASN1SyntaxTest >> testTypeReference [
	self parse: 'A' rule: #typeReference.
	self parse: 'Abc' rule: #typeReference.
	self parse: 'Abc-def' rule: #typeReference.
	self parse: 'Abc-Def34' rule: #typeReference.
	self parse: 'B-a' rule: #typeReference.
	self parse: 'CODE' rule: #typeReference.
	self fail: '' rule: #typeReference.
	self fail: 'abc' rule: #typeReference.
	self fail: 'Abc-def-' rule: #typeReference.
	self fail: 'Abc--def' rule: #typeReference

]

{ #category : #tests }
ASN1SyntaxTest >> testTypeWithConstraint [
	self parse: 'SEQUENCE  (SIZE(32)) OF PairOfCarrierFrequencies' rule: #typeWithConstraint.


]

{ #category : #tests }
ASN1SyntaxTest >> testUnions [
	self parse: '1 | 2' rule: #unions.
	self parse: '1 UNION 2 .. 83' rule: #unions.

]

{ #category : #tests }
ASN1SyntaxTest >> testUpperEndPoint [
	self parse: 'MAX' rule: #upperEndPoint.
	self parse: '<14' rule: #upperEndPoint.
]

{ #category : #tests }
ASN1SyntaxTest >> testUsefulObjectClassReference [
	self parse: 'ABSTRACT-SYNTAX' rule: #usefulObjectClassReference
]

{ #category : #tests }
ASN1SyntaxTest >> testUserDefinedConstraint [
	self parse: 'CONSTRAINED BY { -- must be in the &Linked field of the associated operation --
                }' rule: #userDefinedConstraint.
]

{ #category : #tests }
ASN1SyntaxTest >> testUserDefinedConstraintParameter [
	self parse: 'Foobar:foobar' rule: #userDefinedConstraintParameter.
	self parse: 'Foobar' rule: #userDefinedConstraintParameter.
]

{ #category : #tests }
ASN1SyntaxTest >> testValue [
	self parse: '1' rule: #value.
	self parse: 'foobar' rule: #value.
	self parse: 'Foobar:foobar' rule: #value.


]

{ #category : #tests }
ASN1SyntaxTest >> testValueAssignment [
	self parse: 'foobar Foobar ::= foobar' rule: #valueAssignment.

]

{ #category : #tests }
ASN1SyntaxTest >> testValueFieldReference [
	self parse: '&argumentTypeOptional' rule: #valueFieldReference.
	self fail: '&Errors' rule: #valueFieldReference.
]

{ #category : #tests }
ASN1SyntaxTest >> testValueList [
	self parse: '1,2,3,4,5,6,7' rule: #valueList.

]

{ #category : #tests }
ASN1SyntaxTest >> testValueRange [
	self parse: '10..20' rule: #valueRange.
	self parse: '10< .. < 200' rule: #valueRange.
]

{ #category : #tests }
ASN1SyntaxTest >> testValueSet [
	self parse: '{updateLocation | cancelLocation | purgeMS | sendIdentification | updateGprsLocation | prepareHandover | sendEndSignal }' rule: #valueSet.
	self parse: '{updateLocation | cancelLocation | purgeMS | sendIdentification, ... }' rule: #valueSet.
	self parse: '{updateLocation | cancelLocation | purgeMS | sendIdentification, ..., updateGprsLocation | prepareHandover | sendEndSignal }' rule: #valueSet.


]

{ #category : #tests }
ASN1SyntaxTest >> testValueSetFieldReference [
	self parse: '&ArgumentTypeOptional' rule: #valueSetFieldReference.
	self fail: '&errors' rule: #valueSetFieldReference.
]

{ #category : #tests }
ASN1SyntaxTest >> testValueSetFromObjects [
	self parse: 'updateLocation.&foobar' rule: #valueSetFromObjects.


]

{ #category : #tests }
ASN1SyntaxTest >> testValueSetOptionalitySpec [
	self parse: 'OPTIONAL' rule: #valueSetOptionalitySpec.
	self parse: 'DEFAULT {foobar}' rule: #valueSetOptionalitySpec.


]

{ #category : #tests }
ASN1SyntaxTest >> testValueSetTypeAssignment [
	self parse: 'Foobar Foobar ::= { foobar }' rule: #valueSetTypeAssignment.
	self parse: 'MAPOperations-Invokable OPERATION ::= 
		{sendRoutingInfoForSM | mo-ForwardSM | mt-ForwardSM}' rule: #valueSetTypeAssignment.
]

{ #category : #tests }
ASN1SyntaxTest >> testVariableTypeValueFieldSpec [
	self parse: '&foobar &foo.&bar DEFAULT {foobar}' rule: #variableTypeValueFieldSpec.


]

{ #category : #tests }
ASN1SyntaxTest >> testVariableTypeValueSetFieldSpec [
	self parse: '&Foobar &foo.&bar OPTIONAL' rule: #variableTypeValueSetFieldSpec.


]

{ #category : #tests }
ASN1SyntaxTest >> testVersionNumber [
	self parse: '' rule: #versionNumber.
	self parse: '1:' rule: #versionNumber.
	self fail: '1: ' rule: #versionNumber

]

{ #category : #tests }
ASN1SyntaxTest >> testWithSyntaxSpec [
	self parse: 'WITH SYNTAX {
  [ARGUMENT &ArgumentType
   [OPTIONAL &argumentTypeOptional]]
  [RESULT &ResultType
   [OPTIONAL &resultTypeOptional]]
  [RETURN RESULT &returnResult]
  [ERRORS &Errors]
  [LINKED &Linked]
  [SYNCHRONOUS &synchronous]
  [ALWAYS RESPONDS &alwaysReturns]
  [INVOKE PRIORITY &InvokePriority]
  [RESULT-PRIORITY &ResultPriority]
  [CODE &operationCode]
}' rule: #withSyntaxSpec
]
